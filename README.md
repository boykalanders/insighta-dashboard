# Insighta Dashboard

A production-minded marketing analytics dashboard built with **Next.js 14 App Router**, **TypeScript**, **Tailwind CSS**, and **Supabase** — submitted as a frontend engineering assessment.

> **Live demo:** [https://insighta-dashboard.vercel.app](https://insighta-dashboard.vercel.app)  
> _Note: The live demo runs on mock data. No real Supabase credentials are required to view it._

---

## What It Does

A unified marketing performance dashboard that helps brands understand what drives results across paid and organic channels. Features include:

- **Overview** — KPI cards, revenue/spend time-series chart, attribution funnel, channel breakdown table
- **Campaigns** — searchable, filterable, sortable campaign list with status, ROAS, CPA
- **Channels** — per-channel performance cards and grouped revenue vs. cost bar chart
- **Settings** — profile update form with live Supabase write

---

## Running Locally

```bash
# 1. Clone the repo
git clone https://github.com/oskar/insighta-dashboard.git
cd insighta-dashboard

# 2. Install dependencies
npm install

# 3. Set up environment variables
cp .env.example .env.local
# Edit .env.local with your Supabase project URL and anon key

# 4. (Optional) Apply the database schema
# Open supabase/schema.sql in the Supabase SQL Editor and run it

# 5. Start the dev server
npm run dev
```

Open [http://localhost:3000](http://localhost:3000). You'll be redirected to `/auth/login`.

> **Without a Supabase project:** The app will still render fully — all pages use mock data from `src/lib/mock-data.ts`. Auth operations will fail gracefully with an error message.

---

## Frontend Practices to Notice

### 1. Server vs. Client Component Boundaries

The primary architectural decision in this codebase is placing the **data-fetching and auth boundary at the page/layout level** (Server Components), and pushing interactivity down to leaf components only (Client Components).

- **[`src/app/dashboard/page.tsx`](src/app/dashboard/page.tsx)** — Server Component. Fetches data (or mock data), passes it as plain props. Zero client JS unless children need it.
- **[`src/app/dashboard/layout.tsx`](src/app/dashboard/layout.tsx)** — Server Component. Validates session server-side using `createServerClient()`. This is belt-and-suspenders alongside middleware.
- **[`src/components/charts/revenue-chart.tsx`](src/components/charts/revenue-chart.tsx)** — `"use client"` only because Recharts requires DOM access. The data itself is passed as a prop, not fetched client-side.
- **[`src/components/layout/nav-item.tsx`](src/components/layout/nav-item.tsx)** — `"use client"` only because `usePathname()` requires it. The rest of `<Sidebar>` is a Server Component.

This pattern keeps the client bundle minimal — only components that genuinely need browser APIs are client components.

### 2. Supabase Auth Architecture

Authentication is handled at three layers, each with a clear responsibility:

| Layer | File | Responsibility |
|-------|------|---------------|
| Middleware | [`src/middleware.ts`](src/middleware.ts) | Refreshes session cookie on every request; redirects unauthenticated users away from protected routes |
| Server Client | [`src/lib/supabase/server.ts`](src/lib/supabase/server.ts) | Creates a cookie-aware Supabase client for Server Components and Route Handlers |
| Browser Client | [`src/lib/supabase/client.ts`](src/lib/supabase/client.ts) | Creates a browser-side Supabase client for Client Components |

The auth flow supports both **email + password** and **magic link** (OTP), with the callback handled in [`src/app/auth/callback/route.ts`](src/app/auth/callback/route.ts).

### 3. TypeScript Type System

Types flow from the database schema outward:

- **[`src/types/database.ts`](src/types/database.ts)** — Database shape (meant to be generated by `supabase gen types`). All table row types live here.
- **[`src/types/analytics.ts`](src/types/analytics.ts)** — UI-layer types derived from or extending the database types (e.g., `CampaignRow` with computed fields like `ctr` and `roas`).

This two-layer type system prevents database types from leaking directly into UI components and makes schema changes easier to propagate.

### 4. Component Boundaries

Components are organized by **domain**, not by type:

```
src/components/
  auth/          # Auth-specific forms
  campaigns/     # Campaign list and filters
  channels/      # Channel cards and charts
  charts/        # Pure chart wrappers (Recharts)
  dashboard/     # Overview-specific widgets (metrics grid, date picker)
  layout/        # Structural shell (Sidebar, Topbar, NavItem)
  settings/      # Settings forms
```

Each component has a single responsibility. Charts receive only the data they need — they have no knowledge of where that data came from.

### 5. Mock Data Isolation

All demo data lives in **[`src/lib/mock-data.ts`](src/lib/mock-data.ts)** — a single file that will be removed when real Supabase queries are wired in. Each page has a clearly marked `// TODO:` comment showing exactly where the Supabase query would go, with the shape already defined.

### 6. Design System

A cohesive dark editorial theme built on CSS custom properties:

- Color tokens in [`src/app/globals.css`](src/app/globals.css) — swap a handful of HSL values to re-theme the entire app
- Semantic utility classes (`.glass-card`, `.metric-card`, `.badge-up`, `.nav-item`) defined once in `@layer components`
- Staggered entry animations (`animate-fade-in-delay-*`) for a polished first paint

---

## Project Structure

```
src/
├── app/                         # Next.js App Router
│   ├── layout.tsx               # Root layout (html, body, fonts)
│   ├── page.tsx                 # Root redirect (→ /dashboard or /auth/login)
│   ├── globals.css              # Design tokens, base styles
│   ├── auth/
│   │   ├── login/page.tsx       # Login page (Server Component)
│   │   └── callback/route.ts    # OAuth/OTP callback Route Handler
│   ├── dashboard/
│   │   ├── layout.tsx           # Shared shell layout (auth check)
│   │   └── page.tsx             # Overview page
│   ├── campaigns/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── channels/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   └── settings/
│       ├── layout.tsx
│       └── page.tsx
├── components/
│   ├── auth/login-form.tsx      # Client: email/password + magic link form
│   ├── campaigns/               # Campaign table with filters
│   ├── channels/                # Channel cards
│   ├── charts/                  # Recharts wrappers
│   ├── dashboard/               # KPI widgets, date picker
│   └── layout/                  # Sidebar, Topbar, NavItem
├── lib/
│   ├── supabase/
│   │   ├── client.ts            # Browser Supabase client
│   │   └── server.ts            # Server Supabase client (cookie-aware)
│   ├── mock-data.ts             # Demo data (replace with real queries)
│   └── utils.ts                 # cn(), formatters
├── middleware.ts                 # Session refresh + route protection
└── types/
    ├── analytics.ts             # UI-layer types
    └── database.ts              # DB schema types (generate via Supabase CLI)
supabase/
└── schema.sql                   # Full database schema + RLS policies
```

---

## Assumptions and Trade-offs

**Mock data over a seeded database.** The app works out of the box without a Supabase project. Real queries are stubbed with clear `// TODO:` comments. This was a deliberate trade-off to keep the setup friction-to-zero for reviewers.

**Shared dashboard shell.** Each route section (`/campaigns`, `/channels`, `/settings`) has its own `layout.tsx` that repeats the `<Sidebar>/<Topbar>` shell. A production app might use a route group `(dashboard)` with a single shared layout. I kept them separate to make per-route metadata and auth checks explicit and easy to find.

**No route group for auth protection.** Middleware handles global route protection. The belt-and-suspenders server-side `getUser()` call in each layout is intentional — it prevents flash-of-unauthenticated-content on slow networks.

**No `loading.tsx` files.** Suspense boundaries and skeleton loaders are the right production approach but were omitted to keep scope manageable. The staggered CSS animations serve as a lightweight substitute.

**TypeScript database types are hand-written.** In a real project these would be generated via `npx supabase gen types typescript`. The stub in `src/types/database.ts` mirrors the schema in `supabase/schema.sql` exactly.

---

## Environment Variables

| Variable | Required | Description |
|----------|----------|-------------|
| `NEXT_PUBLIC_SUPABASE_URL` | Yes* | Your Supabase project URL |
| `NEXT_PUBLIC_SUPABASE_ANON_KEY` | Yes* | Supabase anon/public key |
| `SUPABASE_SERVICE_ROLE_KEY` | No | Service role key for admin operations |

*Required for auth to work. The UI renders fine without them using mock data.

---

## Tech Stack

| Tool | Version | Purpose |
|------|---------|---------|
| Next.js | 14.x | Framework (App Router) |
| TypeScript | 5.x | Type safety throughout |
| Tailwind CSS | 3.x | Styling + design tokens |
| Supabase | 2.x | Auth + database |
| Recharts | 2.x | Charts |
| Lucide React | 0.400 | Icons |
| date-fns | 3.x | Date formatting |
